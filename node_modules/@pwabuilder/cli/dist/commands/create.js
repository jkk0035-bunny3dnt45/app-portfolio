"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.desc = exports.command = void 0;
const prompts = __importStar(require("@clack/prompts"));
const fileUtil_1 = require("../util/fileUtil");
const util_1 = require("../util/util");
const usage_analytics_1 = require("../analytics/usage-analytics");
const promptUtil_1 = require("../util/promptUtil");
const textUtil_1 = require("../util/textUtil");
const campaignUtil_1 = require("../util/campaignUtil");
const COMMAND_DESCRIPTION_STRING = 'Create a new progressive web app from a template.';
const NAME_DESCRIPTION_STRING = 'The name of your new PWA project.';
const TEMPLATE_DESCRIPTION_STRING = 'The template to start your project from.';
const LIST_DESCRIPTION_STRING = 'List template options.';
exports.command = 'create [name]';
exports.desc = COMMAND_DESCRIPTION_STRING;
const DEFAULT_NAME = 'pwa-starter';
const DEFAULT_TEMPLATE = 'default';
const DEFAULT_TITLE = 'PWA Starter';
const ARTIFACT_NAMES = (name) => {
    return [fileUtil_1.FETCHED_ZIP_NAME_STRING, fileUtil_1.DECOMPRESSED_NAME_STRING, name];
};
const TEMPLATE_TO_URL_MAP = {
    'default': ["https://github.com/pwa-builder/pwa-starter/archive/refs/heads/main.zip", "pwa-starter-main"],
    'basic': ["https://github.com/pwa-builder/pwa-starter-basic/archive/refs/heads/main.zip", "pwa-starter-basic-main"],
    'whisper': ["https://github.com/pwa-builder/pwa-whisper-starter/archive/refs/heads/main.zip", "pwa-whisper-starter-main"]
};
const USAGE_STRING = '$0 create [name] [-t|--template]';
const NAME_PROMPT_STRING = 'Enter a name for your new PWA: ';
const NAME_PLACEHOLDER_STRING = 'example-pwa-name';
const TEMPLATE_LIST_OUTPUT_STRING = `Available templates:

1. ${(0, textUtil_1.formatEmphasis)("default")} - Original PWA Starter template.
2. ${(0, textUtil_1.formatEmphasis)("basic")} - Simplified PWA Starter with fewer dependencies
3. ${(0, textUtil_1.formatEmphasis)("whisper")} - PWA Starter with transformers.js (set up to use Whisper) and Fluent UI

You can specify a template with the ${(0, textUtil_1.formatCodeSnippet)('-t (--template)')} flag.
For example: ${(0, textUtil_1.formatCodeSnippet)('pwa create -t="default"')}`;
const FETCH_TASK_START_STRING = (template) => { return `Fetching ${template} PWA Starter template`; };
const FETCH_TASK_END_STRING = (0, textUtil_1.formatSuccessEmphasis)('Template fetched.');
const FETCH_TASK_STOP_STRING = (0, textUtil_1.formatErrorEmphasisWeak)('Template fetch cancelled.');
const INSTALL_TASK_START_STRING = 'Installing dependencies';
const INSTALL_TASK_END_STRING = (0, textUtil_1.formatSuccessEmphasis)('Dependencies installed.');
const INSTALL_TASK_STOP_STRING = (name) => {
    return `${(0, textUtil_1.formatErrorEmphasisWeak)('Dependency install cancelled.')} You can still access your PWA in the ${(0, textUtil_1.formatCodeSnippet)(name)} directory.`;
};
const TASK_GROUP_EXIT_STRING = 'PWA create process exited.';
const FINAL_OUTPUT_STRING = (name) => {
    return `${(0, textUtil_1.formatSuccessEmphasis)('All set!')} 
   To preview your PWA in the browser:
  
   1. Navigate to your project's directory with: ${(0, textUtil_1.formatCodeSnippet)("cd " + name)}
   2. Start your PWA with: ${(0, textUtil_1.formatCodeSnippet)("pwa start")}

   Make sure to visit ${(0, textUtil_1.formatEmphasis)("docs.pwabuilder.com")} for further guidance on developing with the PWA Starter.`;
};
const INVALID_NAME_ERROR_STRING = 'Invalid name. A valid project name must not already exist and may only contain alphanumeric characters, dashes, and underscores.';
const INVALID_TEMPLATE_ERROR_STRING = `Invalid template provided. Cancelling create operation.
    
Valid template names:
1. ${(0, textUtil_1.formatErrorEmphasisStrong)("default")} - Original PWA Starter template
2. ${(0, textUtil_1.formatErrorEmphasisStrong)("basic")} - Simplified PWA Starter with fewer dependencies
3. ${(0, textUtil_1.formatErrorEmphasisStrong)("whisper")} - PWA Starter with transformers.js (set up to use Whisper) and Fluent UI`;
const DEFAULT_DEVOPS_REPLACE_LIST = [
    "swa-cli.config.json",
    "package-lock.json",
    "package.json"
];
const DEFAULT_CONTENT_REPLACE_LIST = [
    "index.html",
    "public/manifest.json",
    "src/components/header.ts"
];
const builder = (yargs) => yargs
    .options({
    template: { type: 'string', alias: 't', description: TEMPLATE_DESCRIPTION_STRING },
    list: { type: 'boolean', alias: 'l', description: LIST_DESCRIPTION_STRING }
})
    .positional('name', { type: "string", demandOption: false, description: NAME_DESCRIPTION_STRING })
    .usage(USAGE_STRING);
exports.builder = builder;
const handler = async (argv) => {
    try {
        (0, campaignUtil_1.handleCampaign)(campaignUtil_1.WHISPER_CAMPAIGN);
        await handleCreateCommand(argv);
    }
    catch (error) {
        (0, usage_analytics_1.trackErrorWrapper)(error);
    }
};
exports.handler = handler;
async function handleCreateCommand(argv) {
    const { resolvedName, resolvedTemplate } = await resolveCreateArguments(argv);
    (0, usage_analytics_1.trackCreateEventWrapper)({ template: resolvedTemplate });
    await fetchAndPrepareTemplate(resolvedName, resolvedTemplate);
    finalOutput(resolvedName);
}
async function resolveCreateArguments(argv) {
    const { name, template, list } = argv;
    handleTemplateListFlag(list);
    const resolvedTemplate = await resolveTemplateArgument(template, ('template' in argv));
    const resolvedName = await resolveNameArgument(name);
    return { resolvedName, resolvedTemplate };
}
async function fetchAndPrepareTemplate(resolvedName, resolvedTemplate) {
    const spinnerItems = [
        {
            startText: FETCH_TASK_START_STRING(resolvedTemplate),
            functionToRun: async () => await fetchTask(resolvedName, resolvedTemplate),
            endText: FETCH_TASK_END_STRING,
            stopMessage: FETCH_TASK_STOP_STRING,
            onCancel: () => {
                (0, fileUtil_1.removeAll)(ARTIFACT_NAMES(resolvedName));
            }
        },
        {
            startText: INSTALL_TASK_START_STRING,
            functionToRun: async () => await installTask(resolvedName),
            endText: INSTALL_TASK_END_STRING,
            stopMessage: INSTALL_TASK_STOP_STRING(resolvedName)
        }
    ];
    await (0, promptUtil_1.runSpinnerGroup)(spinnerItems, TASK_GROUP_EXIT_STRING);
}
async function fetchTask(resolvedName, resolvedTemplate) {
    await (0, fileUtil_1.fetchZipAndDecompress)(TEMPLATE_TO_URL_MAP[resolvedTemplate][0]);
    await fixDirectoryStructure(resolvedName, fileUtil_1.DECOMPRESSED_NAME_STRING, resolvedTemplate);
}
async function installTask(resolvedName) {
    await prepDirectoryForDevelopment(resolvedName);
}
function finalOutput(resolvedName) {
    prompts.outro(FINAL_OUTPUT_STRING(resolvedName));
}
async function resolveNameArgument(nameArg) {
    let name = DEFAULT_NAME;
    if (!nameArg || !validateName(nameArg)) {
        name = await prompts.text({
            message: NAME_PROMPT_STRING,
            placeholder: NAME_PLACEHOLDER_STRING,
            initialValue: incrementToUnusedFilename(),
            validate(value) {
                if (!validateName(value)) {
                    return INVALID_NAME_ERROR_STRING;
                }
            },
        });
        if (prompts.isCancel(name)) {
            (0, promptUtil_1.promptsCancel)();
        }
    }
    else {
        name = nameArg;
    }
    return name;
}
async function resolveTemplateArgument(templateArg, templateProvided) {
    let template = DEFAULT_TEMPLATE;
    if (templateArg && validateTemplate(templateArg)) {
        template = templateArg;
    }
    else if (templateProvided) {
        (0, promptUtil_1.promptsCancel)(INVALID_TEMPLATE_ERROR_STRING);
    }
    return template;
}
function validateTemplate(template) {
    return TEMPLATE_TO_URL_MAP.hasOwnProperty(template);
}
function validateName(name) {
    const isValidNameRegex = /^[a-zA-Z0-9_-]+$/;
    return !(0, fileUtil_1.doesFileExist)(name) && isValidNameRegex.test(name);
}
function setNewName(newName) {
    (0, fileUtil_1.replaceInFileList)(DEFAULT_DEVOPS_REPLACE_LIST, DEFAULT_NAME, newName, newName);
    (0, fileUtil_1.replaceInFileList)(DEFAULT_CONTENT_REPLACE_LIST, DEFAULT_TITLE, newName, newName);
}
function incrementToUnusedFilename() {
    let directoryName = DEFAULT_NAME;
    var iteration = 0;
    while ((0, fileUtil_1.doesFileExist)(directoryName)) {
        iteration = iteration + 1;
        directoryName = `${DEFAULT_NAME}-${iteration}`;
    }
    return directoryName;
}
function fixDirectoryStructure(newName, decompressedName, template) {
    (0, fileUtil_1.renameDirectory)(`${decompressedName}/${TEMPLATE_TO_URL_MAP[template][1]}`, `./${newName}`);
    (0, fileUtil_1.removeDirectory)(decompressedName);
}
async function prepDirectoryForDevelopment(newName) {
    try {
        if (newName != DEFAULT_NAME) {
            setNewName(newName);
        }
        await (0, util_1.promisifiedExecWrapper)('npm i', true, newName);
    }
    catch (err) {
        (0, promptUtil_1.promptsCancel)();
    }
}
function handleTemplateListFlag(listFlag) {
    if (listFlag) {
        (0, util_1.outputMessage)(TEMPLATE_LIST_OUTPUT_STRING);
        process.exit(0);
    }
}
//# sourceMappingURL=create.js.map