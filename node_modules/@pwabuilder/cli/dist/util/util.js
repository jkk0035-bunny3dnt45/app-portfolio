"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeProcessEventListeners = exports.replaceProcessEventListeners = exports.timeFunction = exports.isDirectoryTemplate = exports.outputError = exports.outputMessage = exports.spawnWrapper = exports.promisifiedExecWrapper = void 0;
const node_child_process_1 = require("node:child_process");
const fileUtil_1 = require("./fileUtil");
const node_util_1 = require("node:util");
const promisifiedExec = (0, node_util_1.promisify)(require('node:child_process').exec);
const path = require('path');
const defaultErrorMessage = "Command failed due to unknown error.";
async function promisifiedExecWrapper(command, suppressOutput, directory) {
    try {
        await promisifiedExec(command, {
            stdio: suppressOutput ? 'pipe' : [0, 1, 2],
            cwd: path.resolve(process.cwd(), directory ? directory : '')
        });
    }
    catch (err) {
        console.error("Process exited with error.");
    }
}
exports.promisifiedExecWrapper = promisifiedExecWrapper;
async function spawnWrapper(spawnString, suppressOutput = false) {
    try {
        spawnHandler(spawnString, suppressOutput);
    }
    catch (err) {
        console.error("Process exited with error.");
    }
}
exports.spawnWrapper = spawnWrapper;
async function spawnHandler(spawnString, suppressOutput) {
    const { command, args } = parseSpawnString(spawnString);
    const spawnedChild = (0, node_child_process_1.spawn)(command, args, {
        cwd: process.cwd(),
        shell: true
    });
    if (!suppressOutput) {
        spawnedChild.stdout.on('data', (data) => {
            process.stdout.write(data.toString());
        });
    }
}
function parseSpawnString(spawnString) {
    const splitCommand = spawnString.split(' ');
    return {
        command: splitCommand[0],
        args: splitCommand.slice(1)
    };
}
function outputMessage(message) {
    process.stdout.write(message + '\n');
}
exports.outputMessage = outputMessage;
function outputError(message) {
    if (message) {
        process.stderr.write(message + '\n');
    }
    else {
        process.stderr.write(defaultErrorMessage + '\n');
    }
}
exports.outputError = outputError;
function isDirectoryTemplate(directory) {
    const indexPath = directory ? path.resolve(directory, 'index.html') : path.resolve(process.cwd(), 'index.html');
    const testString = "<meta name=\"pwa-starter-template-identity\"";
    return (0, fileUtil_1.doesFileExist)(indexPath) && (0, fileUtil_1.doesStringExistInFile)(indexPath, testString);
}
exports.isDirectoryTemplate = isDirectoryTemplate;
async function timeFunction(functionToTime) {
    const startTime = performance.now();
    await functionToTime();
    const endTime = performance.now();
    return Math.round(endTime - startTime);
}
exports.timeFunction = timeFunction;
function replaceProcessEventListeners(eventNames, handler) {
    removeProcessEventListeners(eventNames);
    addProcessEventListeners(eventNames, handler);
}
exports.replaceProcessEventListeners = replaceProcessEventListeners;
function removeProcessEventListeners(eventNames) {
    for (let eventName of eventNames) {
        process.removeAllListeners(eventName);
    }
}
exports.removeProcessEventListeners = removeProcessEventListeners;
function addProcessEventListeners(eventNames, handler) {
    for (var eventName of eventNames) {
        process.on(eventName, handler);
    }
}
//# sourceMappingURL=util.js.map